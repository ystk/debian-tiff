From 40a5955cbf0df62b1f9e9bd7d9657b0070725d19 Mon Sep 17 00:00:00 2001
From: erouault <erouault>
Date: Mon, 29 Dec 2014 12:09:11 +0000
Subject: [PATCH] * libtiff/tif_next.c: add new tests to check that we don't
 read outside of the compressed input stream buffer.

* libtiff/tif_getimage.c: in OJPEG case, fix checks on strile width/height

[benh: Backported to 3.9.4: adjust context]
---
 ChangeLog              |  9 +++++++++
 libtiff/tif_getimage.c | 12 +++++++-----
 libtiff/tif_next.c     |  4 +++-
 3 files changed, 19 insertions(+), 6 deletions(-)

--- a/libtiff/tif_getimage.c
+++ b/libtiff/tif_getimage.c
@@ -1740,7 +1740,7 @@ DECLAREContigPutFunc(putcontig8bitYCbCr4
 
     (void) y;
     fromskew = (fromskew * 10) / 4;
-    if ((h & 3) == 0 && (w & 1) == 0) {
+    if ((w & 3) == 0 && (h & 1) == 0) {
         for (; h >= 2; h -= 2) {
             x = w>>2;
             do {
@@ -1817,7 +1817,7 @@ DECLAREContigPutFunc(putcontig8bitYCbCr4
     /* XXX adjust fromskew */
     do {
 	x = w>>2;
-	do {
+	while(x>0) {
 	    int32 Cb = pp[4];
 	    int32 Cr = pp[5];
 
@@ -1828,7 +1828,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr4
 
 	    cp += 4;
 	    pp += 6;
-	} while (--x);
+		x--;
+	}
 
         if( (w&3) != 0 )
         {
@@ -1919,7 +1920,7 @@ DECLAREContigPutFunc(putcontig8bitYCbCr2
 	fromskew = (fromskew * 4) / 2;
 	do {
 		x = w>>1;
-		do {
+		while(x>0) {
 			int32 Cb = pp[2];
 			int32 Cr = pp[3];
 
@@ -1928,7 +1929,8 @@ DECLAREContigPutFunc(putcontig8bitYCbCr2
 
 			cp += 2;
 			pp += 4;
-		} while (--x);
+			x --;
+		}
 
 		if( (w&1) != 0 )
 		{
--- a/libtiff/tif_next.c
+++ b/libtiff/tif_next.c
@@ -65,7 +65,7 @@ NeXTDecode(TIFF* tif, tidata_t buf, tsiz
 	bp = (unsigned char *)tif->tif_rawcp;
 	cc = tif->tif_rawcc;
 	scanline = tif->tif_scanlinesize;
-	for (row = buf; occ > 0; occ -= scanline, row += scanline) {
+	for (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {
 		n = *bp++, cc--;
 		switch (n) {
 		case LITERALROW:
@@ -84,6 +84,8 @@ NeXTDecode(TIFF* tif, tidata_t buf, tsiz
 			 * The scanline has a literal span that begins at some
 			 * offset.
 			 */
+			if( cc < 4 )
+				goto bad;
 			off = (bp[0] * 256) + bp[1];
 			n = (bp[2] * 256) + bp[3];
 			if (cc < 4+n || off+n > scanline)
