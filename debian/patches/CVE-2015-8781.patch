Description: fix potential out-of-bound reads/writes in decode functions in tif_luv.c
 Patch adapted from upstream commit aaab5c3c9d2a2c6984f23ccbc79702610439bc65
 Fixes CVE-2015-8781, CVE-2015-8782, CVE-2015-8783
 (bugzilla #2522)
Author: Even Rouault <even.rouault at spatialys.com>
Bug: http://bugzilla.maptools.org/show_bug.cgi?id=2522

--- a/libtiff/tif_luv.c
+++ b/libtiff/tif_luv.c
@@ -183,6 +183,7 @@ struct logLuvState {
 static int
 LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 {
+	static const char module[] = "LogL16Decode";
 	LogLuvState* sp = DecoderState(tif);
 	int shft, i, npixels;
 	unsigned char* bp;
@@ -198,7 +199,11 @@ LogL16Decode(TIFF* tif, tidata_t op, tsi
 	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
 		tp = (int16*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (int16*) sp->tbuf;
 	}
 	_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));
@@ -207,8 +212,10 @@ LogL16Decode(TIFF* tif, tidata_t op, tsi
 	cc = tif->tif_rawcc;
 					/* get each byte string */
 	for (shft = 2*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
+				if( cc < 2 )
+					break;
 				rc = *bp++ + (2-128);
 				b = (int16)(*bp++ << shft);
 				cc -= 2;
@@ -219,6 +226,8 @@ LogL16Decode(TIFF* tif, tidata_t op, tsi
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (int16)*bp++ << shft;
 			}
+		}
+
 		if (i != npixels) {
 			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 		"LogL16Decode: Not enough data at row %d (short %d pixels)",
@@ -240,6 +249,7 @@ LogL16Decode(TIFF* tif, tidata_t op, tsi
 static int
 LogLuvDecode24(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 {
+	static const char module[] = "LogLuvDecode24";
 	LogLuvState* sp = DecoderState(tif);
 	int cc, i, npixels;
 	unsigned char* bp;
@@ -253,13 +263,17 @@ LogLuvDecode24(TIFF* tif, tidata_t op, t
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32 *)op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (uint32 *) sp->tbuf;
 	}
 					/* copy to array of uint32 */
 	bp = (unsigned char*) tif->tif_rawcp;
 	cc = tif->tif_rawcc;
-	for (i = 0; i < npixels && cc > 0; i++) {
+	for (i = 0; i < npixels && cc >= 3; i++) {
 		tp[i] = bp[0] << 16 | bp[1] << 8 | bp[2];
 		bp += 3;
 		cc -= 3;
@@ -282,6 +296,7 @@ LogLuvDecode24(TIFF* tif, tidata_t op, t
 static int
 LogLuvDecode32(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
 {
+	static const char module[] = "LogLuvDecode32";
 	LogLuvState* sp;
 	int shft, i, npixels;
 	unsigned char* bp;
@@ -298,7 +313,11 @@ LogLuvDecode32(TIFF* tif, tidata_t op, t
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (uint32*) sp->tbuf;
 	}
 	_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));
@@ -307,8 +326,10 @@ LogLuvDecode32(TIFF* tif, tidata_t op, t
 	cc = tif->tif_rawcc;
 					/* get each byte string */
 	for (shft = 4*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
+				if( cc < 2 )
+					break;
 				rc = *bp++ + (2-128);
 				b = (uint32)*bp++ << shft;
 				cc -= 2;
@@ -319,6 +340,7 @@ LogLuvDecode32(TIFF* tif, tidata_t op, t
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (uint32)*bp++ << shft;
 			}
+		}
 		if (i != npixels) {
 			TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 		"LogLuvDecode32: Not enough data at row %d (short %d pixels)",
@@ -372,6 +394,7 @@ LogLuvDecodeTile(TIFF* tif, tidata_t bp,
 static int
 LogL16Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 {
+	static const char module[] = "LogL16Encode";
 	LogLuvState* sp = EncoderState(tif);
 	int shft, i, j, npixels;
 	tidata_t op;
@@ -387,7 +410,11 @@ LogL16Encode(TIFF* tif, tidata_t bp, tsi
 		tp = (int16*) bp;
 	else {
 		tp = (int16*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 					/* compress each byte string */
@@ -460,6 +487,7 @@ LogL16Encode(TIFF* tif, tidata_t bp, tsi
 static int
 LogLuvEncode24(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 {
+	static const char module[] = "LogLuvEncode24";
 	LogLuvState* sp = EncoderState(tif);
 	int i, npixels, occ;
 	tidata_t op;
@@ -473,7 +501,11 @@ LogLuvEncode24(TIFF* tif, tidata_t bp, t
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 					/* write out encoded pixels */
@@ -505,6 +537,7 @@ LogLuvEncode24(TIFF* tif, tidata_t bp, t
 static int
 LogLuvEncode32(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)
 {
+	static const char module[] = "LogLuvEncode32";
 	LogLuvState* sp = EncoderState(tif);
 	int shft, i, j, npixels;
 	tidata_t op;
@@ -521,7 +554,11 @@ LogLuvEncode32(TIFF* tif, tidata_t bp, t
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 					/* compress each byte string */
